Estou fazendo um desafio tÃ©cnico para uma empresa, me ajude a realiza-lo, jÃ¡ fiz o backend e agora estou desenvolvendo o frontend, me ajude a implementar o backend no frontend e me oriente para os proximos passos  ðŸ“˜ **RelatÃ³rio TÃ©cnico do Projeto â€“ Monitoramento de EficiÃªncia por Temperatura**  ðŸ§° Stack utilizada - **Backend:** Node.js + TypeScript + PostgreSQL (SQL puro, sem ORM) - **Frontend:** HTML + CSS + JS (estÃ¡tico) - **API externa:** OpenWeather para consulta climÃ¡tica - **Design UI/UX:** Figma com layout em dashboard - **Banco de dados:** PostgreSQL local, com queries SQL puras conforme exigido no desafio - Grafico - ApexChartsjs  quero um grafico de linha com dois itens, temperatura e eficiencia ---  âœ… Escopo do Desafio Conforme documento oficial: - O sistema deve mostrar a **temperatura atual e eficiÃªncia da mÃ¡quina** - A **eficiÃªncia aumenta linearmente de 75% (â‰¤24Â°C) atÃ© 100% (â‰¥28Â°C)** - A pÃ¡gina deve se **atualizar a cada 30 segundos**, exibindo: - Temperatura - EficiÃªncia - Data/hora - GrÃ¡fico de histÃ³rico - Backend deve salvar os dados no banco via **queries SQL** - Dados devem vir de uma **API REST** (OpenWeather) - Interface e incrementos serÃ£o avaliados como diferencial ---  ðŸ§± **Estrutura da Interface** A interface Ã© composta por **quatro blocos principais**:  1. **Bloco superior â€“ Ãšltimos dados (1Âª coluna)** - Exibe: - **Timer**: quanto tempo falta para a prÃ³xima atualizaÃ§Ã£o automÃ¡tica. - **HorÃ¡rio do Ãºltimo registro** (`HH:MM:SS`) - **Data do Ãºltimo registro** (`DD/MM/AAAA`) - **Temperatura registrada** com um **indicativo de tendÃªncia** (subindo, mantendo ou descendo). - Esse indicativo Ã© baseado na comparaÃ§Ã£o entre o Ãºltimo e o penÃºltimo registro.  2. **Bloco superior â€“ Comparativo histÃ³rico (2Âª coluna)** - Dividido em trÃªs sub-blocos: - **MÃªs passado** - **Semana passada** - **Ontem** - Cada bloco compara os **dados atuais de temperatura e eficiÃªncia** com os valores registrados nesses mesmos perÃ­odos, no mesmo horÃ¡rio (ex: 14h de ontem vs. 14h de hoje).  3. **Bloco superior â€“ Destaques (3Âª coluna)** - Subdividido em dois: - **Temperatura media com base no escopo** em destaque, com: - Temperatura mÃ­nima base no escopo - Temperatura mÃ¡xima com base no escopo selecionado - LocalizaÃ§Ã£o atual monitorada - DescriÃ§Ã£o sobre o clima (ex. cÃ©u limpo) - **EficiÃªncia media com base no escopo**** em destaque, com: - Status de desempenho com base na **perda mÃ©dia de eficiÃªncia** - Esse status analisa os dados do **perÃ­odo selecionado no grÃ¡fico** (ex: mÃªs)  4. **Bloco inferior â€“ GrÃ¡fico de linha** - Um grÃ¡fico interativo com: - **Linha de temperatura e eficiÃªncia** ao longo do tempo - **Legenda clara** - Seletor de perÃ­odo (tipo `input radio`) com trÃªs opÃ§Ãµes: - Dia - Semana - MÃªs - Ao mudar o perÃ­odo selecionado, o grÃ¡fico e os dados associados sÃ£o atualizados dinamicamente. ---  ðŸ” Comportamento do Sistema - A pÃ¡gina faz **requisiÃ§Ãµes a cada 30 segundos** - TambÃ©m executa coleta na **primeira carga** - **Timer reinicia** quando a pÃ¡gina Ã© carregada âœ… (_acrescentado com base na sua observaÃ§Ã£o_) - Backend consulta a API, calcula eficiÃªncia e salva os dados no banco - Dados alimentam cards, comparativos e o grÃ¡fico -----  ðŸ§  LÃ³gica principal: 1. **Ao carregar a pÃ¡gina**: - âœ… Fazer `fetch('/api/metrics/collect')` imediatamente - âœ… Atualizar a UI com o retorno - âœ… Iniciar um timer regressivo de 30 segundos 2. **A cada 30 segundos**: - âœ… Fazer novamente `fetch('/api/metrics/collect')` - âœ… Atualizar a UI - âœ… Reiniciar o contador 3. **Se o usuÃ¡rio recarregar a pÃ¡gina**: - âœ… Tudo reinicia do zero â€” novo dado no banco + novo ciclo de 30s ---  ðŸ“¡ Endpoints Implementados | Endpoint                          | FunÃ§Ã£o                                                                   | | --------------------------------- | ------------------------------------------------------------------------ | | `/api/metrics/collect`            | Consulta clima, calcula eficiÃªncia e retorna mÃ©trica + `clima` + `trend` | | `/api/metrics/latest`             | Retorna Ãºltimo registro salvo (sem `clima` ou `trend`)                   | | `/api/metrics/history?range=week` | Retorna mÃ©tricas dentro do range `day`, `week` ou `month`                | | `/api/metrics/stats?range=week`   | Retorna mÃ©dia, min e max de temperatura e eficiÃªncia no range            | | `/api/metrics/comparative`        | Retorna dados comparativos com ontem, semana passada e mÃªs passado       | ---  ðŸ—‚ï¸ Estrutura de Pastas pgsql CopiarEditar server/ â”œâ”€â”€ src/ â”‚   â”œâ”€â”€ controllers/ â”‚   â”‚   â””â”€â”€ metricsController.ts â”‚   â”œâ”€â”€ routes/ â”‚   â”‚   â””â”€â”€ metricsRoutes.ts â”‚   â”œâ”€â”€ services/ â”‚   â”‚   â”œâ”€â”€ weatherService.ts â”‚   â”‚   â”œâ”€â”€ metricService.ts â”‚   â”‚   â””â”€â”€ efficiencyService.ts â”‚   â”œâ”€â”€ db/ â”‚   â”‚   â”œâ”€â”€ setup.ts â”‚   â”‚   â””â”€â”€ pgClient.ts â”‚   â”œâ”€â”€ utils/ â”‚   â”œâ”€â”€ app.ts               onde configura express e as rotas â”‚   â””â”€â”€ index.ts             onde inicia o servidor â”œâ”€â”€ public/                  frontend estÃ¡tico â”‚   â”œâ”€â”€ index.html â”‚   â”œâ”€â”€ css/ â”‚   â”‚   â””â”€â”€ style.css â”‚   â””â”€â”€ js/ â”‚       â””â”€â”€ main.js â”œâ”€â”€ .env â”œâ”€â”€ tsconfig.json â”œâ”€â”€ package.json ---  ðŸ› ï¸ DiÃ¡rio de Etapas Realizadas | Etapa | DescriÃ§Ã£o                                                                | | ----- | ------------------------------------------------------------------------ | | 1     | Iniciado com Prisma e datasource PostgreSQL                              | | 2     | Banco configurado no `.env`                                              | | 3     | Criado modelo `Metric` no Prisma                                         | | 4     | Executada a primeira rota de criaÃ§Ã£o de mÃ©trica                          | | 5     | Criada rota `/history?range=` para histÃ³rico por escopo                  | | 6     | Criada rota `/stats?range=` com mÃ©dia, min e max                         | | 7     | **(AlteraÃ§Ã£o)** RemoÃ§Ã£o do Prisma e reescrita usando queries SQL puras âœ… | | 8     | Adicionada anÃ¡lise de tendÃªncia (`trend`) na rota `/collect`             | | 9     | Criada funÃ§Ã£o de comparaÃ§Ã£o com histÃ³rico no endpoint `/comparative`     | ---  âš ï¸ Pontos de AtenÃ§Ã£o - `/latest` nÃ£o inclui `trend` e `clima`, o que pode limitar a UI â€“ pode ser ajustado - Comparativo (`/comparative`) pode retornar `null` caso nÃ£o haja dados suficientes - Frontend deve inicializar o timer ao carregar a pÃ¡gina âœ… (_incluÃ­do como observaÃ§Ã£o sua_) - Armazenar `clima` no banco ainda nÃ£o estÃ¡ implementado (fica sÃ³ no JSON) â€“ pode ser opcional ---  ðŸ“¡ Endpoints da API  âœ… `/api/metrics/collect` - Cria um novo registro no banco - Consulta a OpenWeather - Calcula eficiÃªncia - Retorna: `{   "id": 3,   "temperature": 26.3,   "efficiency": 91.25,   "location": "Patos de Minas",   "createdAt": "2025-05-21T19:24:20.686Z",   "clima": "cÃ©u limpo",   "trend": "up" }` - **`clima` e `trend` nÃ£o sÃ£o salvos no banco**, apenas retornados ao frontend. ðŸŸ¢ **Usar sempre** para: - Primeira coleta ao carregar a pÃ¡gina - AtualizaÃ§Ãµes a cada 30 segundos ---  âš ï¸ `/api/metrics/latest` - Retorna o **Ãºltimo registro salvo no banco** - **NÃ£o inclui `clima` nem `trend`** ðŸŸ¡ **Usar apenas quando:** - A API do clima falhar (ex: sem internet ou limite de requisiÃ§Ãµes excedido) - VocÃª quiser apenas exibir o Ãºltimo dado salvo sem nova consulta externa ---  ðŸ•“ `/api/metrics/history?range=day|week|month` - Retorna lista de mÃ©tricas no perÃ­odo especificado - Usado para alimentar o **grÃ¡fico de linha** ---  ðŸ“Š `/api/metrics/stats?range=day|week|month` - Retorna: - Temperatura mÃ©dia, mÃ­nima, mÃ¡xima - EficiÃªncia mÃ©dia, mÃ­nima, mÃ¡xima ---  ðŸ“ˆ `/api/metrics/comparative` - Compara a mÃ©trica mais recente com: - Ontem - Semana passada - MÃªs passado - Usa uma janela de Â±15 minutos para buscar dados prÃ³ximos no tempo  âœ… Status Atual - âœ… Backend completo e funcional - âœ… Banco de dados em SQL puro (exigÃªncia do desafio) - âœ… API externa integrada com tratamento de erros - âœ… Interface no Figma finalizada - ðŸ•’ InÃ­cio da implementaÃ§Ã£o do **frontend** (comportamento, consumo e timer) ---  ConteÃºdo em cada arquivo:  **server/src/controllers/metricsControllers.ts** ``` import { Request, Response } from 'express'; import { collectAndSaveMetric, getComparativeMetrics, getPreviousMetric, metricService } from '../services/metricService'; import { pool } from '../db/pgClient'; export async function collectMetric(req: Request, res: Response) { try { const metric = await collectAndSaveMetric(); const previous = await getPreviousMetric(metric.id); const trend = calculateTrend(metric.temperature, previous?.temperature); res.status(201).json({ ...metric, clima: metric.clima, trend }); } catch (error) { console.error('Erro ao coletar mÃ©trica:', error); res.status(500).json({ error: 'Erro ao coletar mÃ©trica.' }); } } function calculateTrend(current: number, previous?: number): 'up' | 'down' | 'stable' { if (previous === undefined) return 'stable'; if (current > previous) return 'up'; if (current < previous) return 'down'; return 'stable'; } export async function getLatestMetric(req: Request, res: Response) { try { const result = await metricService.getLatest(); if (!result) { return res.status(404).json({ error: 'Nenhuma mÃ©trica encontrada.' }); } res.json(result); } catch (error) { console.error('Erro ao buscar Ãºltima mÃ©trica:', error); res.status(500).json({ error: 'Erro ao buscar Ãºltima mÃ©trica.' }); } } export async function getHistory(req: Request, res: Response) { const range = req.query.range; if (!isValidRange(range)) { return res.status(400).json({ error: 'ParÃ¢metro range invÃ¡lido' }); } try { const data = await metricService.getHistoryByRange(range); res.json(data); } catch (error) { console.error('Erro ao buscar histÃ³rico:', error); res.status(500).json({ error: 'Erro interno no servidor' }); } } export async function getStats(req: Request, res: Response) { const range = req.query.range; if (!isValidRange(range)) { return res.status(400).json({ error: 'ParÃ¢metro range invÃ¡lido' }); } try { const stats = await metricService.getStatsByRange(range); res.json(stats); } catch (error) { console.error('Erro ao buscar estatÃ­sticas:', error); res.status(500).json({ error: 'Erro interno no servidor' }); } } export async function getComparative(req: Request, res: Response) { try { const latest = await metricService.getLatest(); if (!latest) { return res.status(404).json({ error: 'Nenhuma mÃ©trica encontrada.' }); } const referenceDate = new Date(latest.createdAt); const comparative = await getComparativeMetrics(referenceDate); res.json({ reference: latest, comparative, }); } catch (error) { console.error('Erro no comparativo:', error); res.status(500).json({ error: 'Erro interno no servidor.' }); } } function isValidRange(range: any): range is 'day' | 'week' | 'month' { return ['day', 'week', 'month'].includes(range); } ```  **server/src/db/pgClient.ts** ``` import { Pool } from 'pg'; import dotenv from 'dotenv'; dotenv.config(); export const pool = new Pool({ connectionString: process.env.DATABASE_URL, }); ```  **server/src/db/setup.ts** ``` import { pool } from './pgClient'; export async function setupDatabase() { await pool.query(` CREATE TABLE IF NOT EXISTS metric ( "id" SERIAL PRIMARY KEY, "temperature" FLOAT NOT NULL, "efficiency" FLOAT NOT NULL, "location" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMPTZ DEFAULT NOW() ); `); } ```  **server/src/routes/metricRoutes.ts** ``` import express from 'express'; import { collectMetric, getLatestMetric, getHistory, getStats, getComparative } from '../controllers/metricsController'; const router = express.Router(); // Registrar nova mÃ©trica (quando usuÃ¡rio acessar) router.get('/collect', collectMetric); router.get('/latest', (req, res, next) => { getLatestMetric(req, res).catch(next); }); router.get('/history', (req, res, next) => { getHistory(req, res).catch(next); }); router.get('/stats', (req, res, next) => { getStats(req, res).catch(next); }); router.get('/comparative', (req, res, next) => { getComparative(req, res).catch(next); }); export default router; ```  **server/src/services/efficiencyService.ts** ``` export function calculateEfficiency(temperature: number): number { if (temperature >= 28) return 100; if (temperature <= 24) return 75; const efficiency = 75 + ((temperature - 24) / (28 - 24)) * 25; return parseFloat(efficiency.toFixed(2)); } ```  **server/src/services/metricService.ts** ``` import { getWeatherFromAPI } from "./weatherService"; import { calculateEfficiency } from "./efficiencyService"; import { pool } from "../db/pgClient"; import { subDays, subWeeks, subMonths, setHours, setMinutes, addMinutes, subMinutes, startOfDay, } from 'date-fns'; // FunÃ§Ã£o para registrar uma nova mÃ©trica export async function collectAndSaveMetric() { const city = process.env.LOCATION_DEFAULT || "Patos de Minas"; const { temperature, description } = await getWeatherFromAPI(city); const efficiency = calculateEfficiency(temperature); const insertQuery = ` INSERT INTO metric (temperature, efficiency, location) VALUES ($1, $2, $3) RETURNING *; `; const values = [temperature, efficiency, city]; const result = await pool.query(insertQuery, values); const metric = result.rows[0]; return { ...metric, clima: description }; } // FunÃ§Ã£o auxiliar para calcular data inicial por escopo function getStartDate(range: "day" | "week" | "month") { const now = new Date(); switch (range) { case "day": return startOfDay(now); case "week": return startOfDay(subDays(now, 7)); case "month": return startOfDay(subDays(now, 30)); default: throw new Error("Invalid range"); } } // ServiÃ§o principal export const metricService = { // HistÃ³rico por escopo getHistoryByRange: async (range: "day" | "week" | "month") => { const from = getStartDate(range); const query = ` SELECT * FROM metric WHERE "createdAt" >= $1 ORDER BY "createdAt" ASC; `; const result = await pool.query(query, [from]); return result.rows; }, // EstatÃ­sticas agregadas por escopo getStatsByRange: async (range: "day" | "week" | "month") => { const from = getStartDate(range); const query = ` SELECT AVG(temperature) AS avg_temperature, MIN(temperature) AS min_temperature, MAX(temperature) AS max_temperature, AVG(efficiency) AS avg_efficiency, MIN(efficiency) AS min_efficiency, MAX(efficiency) AS max_efficiency FROM metric WHERE "createdAt" >= $1; `; const result = await pool.query(query, [from]); const row = result.rows[0]; return { temperature: { avg: parseFloat(row.avg_temperature), min: parseFloat(row.min_temperature), max: parseFloat(row.max_temperature), }, efficiency: { avg: parseFloat(row.avg_efficiency), min: parseFloat(row.min_efficiency), max: parseFloat(row.max_efficiency), }, }; }, getLatest: async () => { const query = ` SELECT * FROM metric ORDER BY "id" DESC LIMIT 1; `; const result = await pool.query(query); return result.rows[0]; } }; export async function getComparativeMetrics(referenceDate: Date) { const hour = referenceDate.getHours(); const minute = referenceDate.getMinutes(); const dates = { yesterday: subDays(referenceDate, 1), lastWeek: subWeeks(referenceDate, 1), lastMonth: subMonths(referenceDate, 1), }; const results: Record<string, any> = {}; for (const [key, date] of Object.entries(dates)) { // Base: mesma hora:minuto do referenceDate, mas no perÃ­odo anterior const base = setMinutes(setHours(date, hour), minute); // Arredonda: pega uma janela de Â±15 minutos em torno da base const start = subMinutes(base, 15); const end = addMinutes(base, 15); const query = ` SELECT * FROM metric WHERE "createdAt" BETWEEN $1 AND $2 ORDER BY ABS(EXTRACT(EPOCH FROM "createdAt" - $3)) ASC LIMIT 1; `; // $3: tempo de referÃªncia exato, para ordenar por proximidade const result = await pool.query(query, [start, end, base]); results[key] = result.rows[0] || null; } return results; } export async function getPreviousMetric(currentId: number) { const result = await pool.query(` SELECT * FROM metric WHERE id <> $1 ORDER BY "createdAt" DESC LIMIT 1; `, [currentId]); return result.rows[0]; } ```  **server/src/services/weatherService.ts** ``` import axios from "axios"; export interface WeatherData { temperature: number; description: string; } export async function getWeatherFromAPI(city: string): Promise<WeatherData> { const apiKey = process.env.WEATHER_API_KEY; if (!apiKey) { throw new Error("API KEY do OpenWeather nÃ£o configurada."); } try { const response = await axios.get(`https://api.openweathermap.org/data/2.5/weather`, { params: { q: city, appid: apiKey, units: 'metric', lang: 'pt_br' }, timeout: 5000 // â° Define um tempo limite para evitar travamento }); const temperature = response.data.main?.temp; const description = response.data.weather?.[0]?.description; if (temperature === undefined || !description) { throw new Error('Resposta da API do clima estÃ¡ incompleta.'); } return { temperature, description }; } catch (error: any) { if (axios.isAxiosError(error)) { const status = error.response?.status; if (status === 404) { throw new Error(`Cidade "${city}" nÃ£o encontrada na API de clima.`); } if (status === 401) { throw new Error('API Key invÃ¡lida ou nÃ£o autorizada.'); } throw new Error(`Erro ao consultar API de clima: ${error.message}`); } else { throw new Error(`Erro inesperado: ${error.message}`); } } } ```  **server/src/app.ts** ``` import express from 'express'; import path from 'path'; import metricsRoutes from './routes/metricsRoutes'; const app = express(); app.use(express.json()); // Servir arquivos estÃ¡ticos app.use(express.static(path.join(__dirname, '..', 'public'))); // Rotas da API app.use('/api/metrics', metricsRoutes); export default app; ```  **server/src/index.ts** ``` import dotenv from 'dotenv'; import app from './app'; import { setupDatabase } from './db/setup'; dotenv.config(); const PORT = process.env.PORT || 3000; setupDatabase().then(() => { app.listen(PORT, () => { console.log(`Servidor rodando em http://localhost:${PORT}`); }); }).catch(err => { console.error('Erro ao configurar banco de dados:', err); }); ``` ---  FrontEnd  public/index.html ``` <!DOCTYPE html> <html lang="pt-br"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Effy Analytics</title> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=Inter:opsz,wght@14..32,100..900&display=swap" rel="stylesheet"> <link rel="stylesheet" href="./css/styles.css"> </head> <body> <header> <h1 class="main-title">Effy <span>Analytics</span></h1> <div class="header-content"> <div class="container-localization"> <span data-lucide="map-pin" class="icon"></span> <h2 class="value-localization">Patos de minas</h2> </div> <div class="container-timer"> <span data-lucide="alarm-clock" class="icon"></span> <p><span class="value-timer">30</span>s</p> </div> </div> </header> <main> <nav> <ul> <li> <a aria-label="Dashboard Home" class="nav-button active" href=""> <span data-lucide="house" class="icon"></span> </a> </li> </ul> </nav> <section class="container-dashboard"> <div class="container"> <h2>Dados Atuais</h2> <div class="container-card-data"> <div class="card-data"> <div class="header-card-data"> <p>HorÃ¡rio</p> <span data-lucide="alarm-clock" class="icon"></span> </div> <span class="card-data-info value-time">19:06:21</span> </div> <div class="card-data"> <div class="header-card-data"> <p>Data</p> <span data-lucide="calendar" class="icon"></span> </div> <span class="card-data-info value-date">29/07/2006</span> </div> <div class="card-data"> <div class="header-card-data"> <p>Temperatura</p> <span data-lucide="thermometer" class="icon"></span> </div> <p class="card-data-info"><span class="value-temperature">29,5</span>Â°C</p> <span data-lucide="arrow-right" class="icon value-temperature-trend"></span> <!-- Rotacionar com classes up (apontando na diagonal para cima), down (diagonal para baixo), stable (padrÃ£o)--> </div> <div class="card-data"> <div class="header-card-data"> <p>EficiÃªncia</p> <span data-lucide="gauge" class="icon"></span> </div> <p class="card-data-info"><span class="value-efficiency">85,2</span>%</p> <span data-lucide="arrow-right" class="icon value-efficiency-trend"></span> <!-- Rotacionar com classes up (apontando na diagonal para cima), down (diagonal para baixo), stable (padrÃ£o)--> </div> </div> </div> <div class="container"> <h2>Resumo</h2> <div class="container-card-media"> <div class="card-media"> <div class="header-card-media"> <span>MÃ©dia de</span> <div> <span data-lucide="wind" class="icon"></span> <p class="value-clima">CÃ©u Limpo</p> </div> </div> <div class="content-card-media"> <span data-lucide="thermometer" class="icon"></span> <p><span class="value-media-temperature">29,05</span>Â°C</p> </div> <div class="range-card-media"> <p>min: <span class="value-min-temperature">22</span>Â°C</p> <p>min: <span class="value-max-temperature">32</span>Â°C</p> </div> </div> <div class="card-media"> <div class="header-card-media"> <span>MÃ©dia de</span> <div> <span data-lucide="square-kanban" class="icon"></span> <p>MÃ©dia:<span class="value-defcit">-24</span>%</p> </div> </div> <div class="content-card-media"> <span data-lucide="gauge" class="icon"></span> <p><span class="value-media-efficiency">85,05</span>%</p> </div> <div class="range-card-media"> <p>min: <span class="value-min-efficiency">52</span>%</p> <p>min: <span class="value-max-efficiency">100</span>%</p> </div> </div> </div> </div> <div class="container"> <h2>Comparativo</h2> <div class="container-card-comparative"> <div class="card-comparative"> <h3>Ontem</h3> <div class="card-comparative-content"> <div class="temperature-comparative"> <span data-lucide="thermometer" class="icon"></span> <p><span class="value-yesterday-temperature">29,05</span>Â°C</p> </div> <div class="efficiency-comparative"> <span data-lucide="gauge" class="icon"></span> <p><span class="value-yesterday-efficiency">85,05</span>%</p> </div> </div> </div> <div class="card-comparative"> <h3>Last Week</h3> <div class="card-comparative-content"> <div class="temperature-comparative"> <span data-lucide="thermometer" class="icon"></span> <p><span class="value-last-week-temperature">29,05</span>Â°C</p> </div> <div class="efficiency-comparative"> <span data-lucide="gauge" class="icon"></span> <p><span class="value-last-week-efficiency">85,05</span>%</p> </div> </div> </div> <div class="card-comparative"> <h3>Last Month</h3> <div class="card-comparative-content"> <div class="temperature-comparative"> <span data-lucide="thermometer" class="icon"></span> <p><span class="value-last-month-temperature">29,05</span>Â°C</p> </div> <div class="efficiency-comparative"> <span data-lucide="gauge" class="icon"></span> <p><span class="value-last-month-efficiency">85,05</span>%</p> </div> </div> </div> </div> </div> <div class="container-card-graph"> </div> </section> </main> <script src="./js/scripts.js"></script> <script src="https://unpkg.com/lucide@latest"></script> <script> document.addEventListener('DOMContentLoaded', () => { lucide.createIcons(); }); </script> <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script> </body> </html> ```  public/js/scripts.js ``` document.addEventListener("DOMContentLoaded", function () { let chart; const labels = []; const temperatureData = []; const efficiencyData = []; const options = { chart: { type: 'line', height: '400px', animations: { enabled: true, easing: 'easeinout', speed: 500, animateGradually: { enabled: true, delay: 150 }, dynamicAnimation: { enabled: true, speed: 500 } } }, stroke: { width: 4, curve: 'smooth' }, series: [ { name: 'Temperatura (Â°C)', data: [] }, { name: 'EficiÃªncia (%)', data: [] } ], xaxis: { categories: [], title: { text: 'HorÃ¡rio' } }, yaxis: { title: { text: 'Temperatura (Â°C) / EficiÃªncia (%)' } }, colors: ['FDAD15', '2AC670'], fill: { type: 'gradient', gradient: { shade: 'light', type: "vertical", shadeIntensity: 0.4, opacityFrom: .8, opacityTo: .5, stops: [0, 100] } }, markers: { size: 5, colors: ['FDAD15', '2AC670'], strokeColors: 'fff', strokeWidth: 2 }, legend: { position: 'top', horizontalAlign: 'left' }, tooltip: { theme: 'light' }, grid: { borderColor: "e0e0e0", row: { colors: ['f9f9f9', 'transparent'], opacity: 0.5 } } }; chart = new ApexCharts(document.querySelector(".container-card-graph"), options); chart.render(); // SimulaÃ§Ã£o de chamada Ã  API a cada 30s setInterval(fetchNewData, 1000); // ou 1000 para testar mais rÃ¡pido function fetchNewData() { // Aqui vocÃª faria um fetch real const now = new Date(); const timeLabel = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); const newTemp = (Math.random() * 10 + 25).toFixed(2); const newEff = (Math.random() * 20 + 80).toFixed(2); // Atualiza arrays labels.push(timeLabel); temperatureData.push(parseFloat(newTemp)); efficiencyData.push(parseFloat(newEff)); // Limita os dados a, por exemplo, Ãºltimos 10 pontos if (labels.length > 10) { labels.shift(); temperatureData.shift(); efficiencyData.shift(); } // Atualiza grÃ¡fico chart.updateOptions({ xaxis: { categories: labels } }); chart.updateSeries([ { name: 'Temperatura (Â°C)', data: temperatureData }, { name: 'EficiÃªncia (%)', data: efficiencyData } ]); } // Para inicializaÃ§Ã£o imediata fetchNewData(); }); ```  public/css/styles.css ``` @import url(./header.css); @import url(./nav.css); @import url(./dashboard.css); /* Corrigido 'deshboard.css' para 'dashboard.css' */ :root { --primary-text-color: 1E1E1E; --secondary-text-color: 5E5E5E; --primary-bg-color: F9FAFB; --secondary-bg-color: FFFFFF; --primary-color: FFE066; --positive-color: 2AC670; --negative-color: FF6252; --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); --radius: 12px; --font: 'Inter', sans-serif; } * { margin: 0; padding: 0; box-sizing: border-box; font-family: var(--font), sans-serif; } body { background-color: var(--primary-bg-color); overflow-x: hidden; } ```  public/css/deshboard.css ``` main { margin: 0 2vw; width: 100vw; display: flex; gap: 2vw; position: relative; } /* Dashboard com 2 linhas: 3 colunas acima, 1 abaixo */ .container-dashboard { margin-left: 10vw; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: 1fr 1fr; width: 85vw; gap: 1.5rem; } .container h2 { font-size: 1.2rem; color: var(--text-color); margin-bottom: 0.5em; font-weight: 500; } .container-card-data { height: 100%; display: grid; grid-template-columns: repeat(2, 1fr); /* 2 colunas */ grid-template-rows: repeat(2, 1fr); Â  Â /* 2 linhas */ gap: 1rem; background-color: f4f4f4; border-radius: 10px; } .card-data { background-color: white; padding: 0.8rem; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 0.5rem; } .container-card-media { height: 100%; display: grid; grid-template-rows: repeat(2, 1fr); gap: 0.5rem; } .card-media { background-color: white; padding: 0.8rem; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 0.5rem; } .header-card-media { display: flex; justify-content: space-between; margin: 0 1em; } .header-card-media div { display: flex; align-items: center; gap: 0.5em; } .content-card-media { display: flex; color: var(--text-color); gap: 0.5em; align-items: center; margin: 0.5em 0; margin-left: 2em; } .content-card-media p { font-size: 1.5rem; font-weight: 700; color: var(--text-color); } .range-card-media { display: flex; align-items: center; gap: 2em; margin-left: 1.2em; font-size: 0.8rem; } .container { height: 50vh; } .container-card-comparative { height: 100%; display: grid; grid-template-rows: repeat(3, 1fr); gap: 0.5rem; } .card-comparative { background-color: white; padding: 0.8rem 1.2em; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 0.5rem; } .card-comparative h3{ font-size: 1rem; color: var(--text-color); margin-left: .5em; } .card-comparative-content { display: flex; color: var(--text-color); justify-content: space-between; align-items: center; margin: .2em 12%; } .card-comparative-content div { display: flex; align-items: center; gap: 0.5em; } .container-card-graph { background-color: var(--secondary-bg-color); margin-top: 1em; height: 50vh; width: 100%; grid-column: 1 / -1; height: 400px !important; /* Altura fixa */ position: relative; } ```  public/css/nav.css ``` nav { background-color: var(--secondary-bg-color); display: flex; flex-direction: column; width: 7vw; height: 80%; border-radius: 10px; padding: 5vh 0; position: fixed; align-items: center; } nav ul { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 10px; } nav ul li{ width: 4vw; height: 4vw; border-radius: 100%; display: flex; align-items: center; justify-content: center; } .nav-button { display: flex; width: 100%; border-radius: 100%; height: 100%; align-items: center; justify-content: center; color: var(--text-color); } .active { background-color: var(--primary-color); } ```  public/css/header.css ``` header { display: flex; justify-content: space-between; padding: 0 2vw; height: 15vh; align-items: center; } .main-title { font-size: 1.8rem; font-weight: 700; color: var(--primary-text-color); } .main-title span { font-weight: 300; color: var(--secondary-text-color); } .header-content { display: flex; gap: 5vw; align-items: center; justify-content: center; font-weight: 300; color: var(--secondary-text-color); margin-right: 8vw; } .header-content div { display: flex; align-items: center; gap: 0.5em; justify-content: center; } .value-localization { font-size: 1rem; font-weight: 300; } .container-timer p { font-size: 0.8rem; font-weight: 300; } .value-timer { font-size: 1rem; } ```