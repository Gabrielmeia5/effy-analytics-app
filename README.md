Estou fazendo um desafio técnico para uma empresa, me ajude a realiza-lo, já fiz o backend e agora estou desenvolvendo o frontend, me ajude a implementar o backend no frontend e me oriente para os proximos passos  📘 **Relatório Técnico do Projeto – Monitoramento de Eficiência por Temperatura**  🧰 Stack utilizada - **Backend:** Node.js + TypeScript + PostgreSQL (SQL puro, sem ORM) - **Frontend:** HTML + CSS + JS (estático) - **API externa:** OpenWeather para consulta climática - **Design UI/UX:** Figma com layout em dashboard - **Banco de dados:** PostgreSQL local, com queries SQL puras conforme exigido no desafio - Grafico - ApexChartsjs  quero um grafico de linha com dois itens, temperatura e eficiencia ---  ✅ Escopo do Desafio Conforme documento oficial: - O sistema deve mostrar a **temperatura atual e eficiência da máquina** - A **eficiência aumenta linearmente de 75% (≤24°C) até 100% (≥28°C)** - A página deve se **atualizar a cada 30 segundos**, exibindo: - Temperatura - Eficiência - Data/hora - Gráfico de histórico - Backend deve salvar os dados no banco via **queries SQL** - Dados devem vir de uma **API REST** (OpenWeather) - Interface e incrementos serão avaliados como diferencial ---  🧱 **Estrutura da Interface** A interface é composta por **quatro blocos principais**:  1. **Bloco superior – Últimos dados (1ª coluna)** - Exibe: - **Timer**: quanto tempo falta para a próxima atualização automática. - **Horário do último registro** (`HH:MM:SS`) - **Data do último registro** (`DD/MM/AAAA`) - **Temperatura registrada** com um **indicativo de tendência** (subindo, mantendo ou descendo). - Esse indicativo é baseado na comparação entre o último e o penúltimo registro.  2. **Bloco superior – Comparativo histórico (2ª coluna)** - Dividido em três sub-blocos: - **Mês passado** - **Semana passada** - **Ontem** - Cada bloco compara os **dados atuais de temperatura e eficiência** com os valores registrados nesses mesmos períodos, no mesmo horário (ex: 14h de ontem vs. 14h de hoje).  3. **Bloco superior – Destaques (3ª coluna)** - Subdividido em dois: - **Temperatura media com base no escopo** em destaque, com: - Temperatura mínima base no escopo - Temperatura máxima com base no escopo selecionado - Localização atual monitorada - Descrição sobre o clima (ex. céu limpo) - **Eficiência media com base no escopo**** em destaque, com: - Status de desempenho com base na **perda média de eficiência** - Esse status analisa os dados do **período selecionado no gráfico** (ex: mês)  4. **Bloco inferior – Gráfico de linha** - Um gráfico interativo com: - **Linha de temperatura e eficiência** ao longo do tempo - **Legenda clara** - Seletor de período (tipo `input radio`) com três opções: - Dia - Semana - Mês - Ao mudar o período selecionado, o gráfico e os dados associados são atualizados dinamicamente. ---  🔁 Comportamento do Sistema - A página faz **requisições a cada 30 segundos** - Também executa coleta na **primeira carga** - **Timer reinicia** quando a página é carregada ✅ (_acrescentado com base na sua observação_) - Backend consulta a API, calcula eficiência e salva os dados no banco - Dados alimentam cards, comparativos e o gráfico -----  🧠 Lógica principal: 1. **Ao carregar a página**: - ✅ Fazer `fetch('/api/metrics/collect')` imediatamente - ✅ Atualizar a UI com o retorno - ✅ Iniciar um timer regressivo de 30 segundos 2. **A cada 30 segundos**: - ✅ Fazer novamente `fetch('/api/metrics/collect')` - ✅ Atualizar a UI - ✅ Reiniciar o contador 3. **Se o usuário recarregar a página**: - ✅ Tudo reinicia do zero — novo dado no banco + novo ciclo de 30s ---  📡 Endpoints Implementados | Endpoint                          | Função                                                                   | | --------------------------------- | ------------------------------------------------------------------------ | | `/api/metrics/collect`            | Consulta clima, calcula eficiência e retorna métrica + `clima` + `trend` | | `/api/metrics/latest`             | Retorna último registro salvo (sem `clima` ou `trend`)                   | | `/api/metrics/history?range=week` | Retorna métricas dentro do range `day`, `week` ou `month`                | | `/api/metrics/stats?range=week`   | Retorna média, min e max de temperatura e eficiência no range            | | `/api/metrics/comparative`        | Retorna dados comparativos com ontem, semana passada e mês passado       | ---  🗂️ Estrutura de Pastas pgsql CopiarEditar server/ ├── src/ │   ├── controllers/ │   │   └── metricsController.ts │   ├── routes/ │   │   └── metricsRoutes.ts │   ├── services/ │   │   ├── weatherService.ts │   │   ├── metricService.ts │   │   └── efficiencyService.ts │   ├── db/ │   │   ├── setup.ts │   │   └── pgClient.ts │   ├── utils/ │   ├── app.ts               onde configura express e as rotas │   └── index.ts             onde inicia o servidor ├── public/                  frontend estático │   ├── index.html │   ├── css/ │   │   └── style.css │   └── js/ │       └── main.js ├── .env ├── tsconfig.json ├── package.json ---  🛠️ Diário de Etapas Realizadas | Etapa | Descrição                                                                | | ----- | ------------------------------------------------------------------------ | | 1     | Iniciado com Prisma e datasource PostgreSQL                              | | 2     | Banco configurado no `.env`                                              | | 3     | Criado modelo `Metric` no Prisma                                         | | 4     | Executada a primeira rota de criação de métrica                          | | 5     | Criada rota `/history?range=` para histórico por escopo                  | | 6     | Criada rota `/stats?range=` com média, min e max                         | | 7     | **(Alteração)** Remoção do Prisma e reescrita usando queries SQL puras ✅ | | 8     | Adicionada análise de tendência (`trend`) na rota `/collect`             | | 9     | Criada função de comparação com histórico no endpoint `/comparative`     | ---  ⚠️ Pontos de Atenção - `/latest` não inclui `trend` e `clima`, o que pode limitar a UI – pode ser ajustado - Comparativo (`/comparative`) pode retornar `null` caso não haja dados suficientes - Frontend deve inicializar o timer ao carregar a página ✅ (_incluído como observação sua_) - Armazenar `clima` no banco ainda não está implementado (fica só no JSON) – pode ser opcional ---  📡 Endpoints da API  ✅ `/api/metrics/collect` - Cria um novo registro no banco - Consulta a OpenWeather - Calcula eficiência - Retorna: `{   "id": 3,   "temperature": 26.3,   "efficiency": 91.25,   "location": "Patos de Minas",   "createdAt": "2025-05-21T19:24:20.686Z",   "clima": "céu limpo",   "trend": "up" }` - **`clima` e `trend` não são salvos no banco**, apenas retornados ao frontend. 🟢 **Usar sempre** para: - Primeira coleta ao carregar a página - Atualizações a cada 30 segundos ---  ⚠️ `/api/metrics/latest` - Retorna o **último registro salvo no banco** - **Não inclui `clima` nem `trend`** 🟡 **Usar apenas quando:** - A API do clima falhar (ex: sem internet ou limite de requisições excedido) - Você quiser apenas exibir o último dado salvo sem nova consulta externa ---  🕓 `/api/metrics/history?range=day|week|month` - Retorna lista de métricas no período especificado - Usado para alimentar o **gráfico de linha** ---  📊 `/api/metrics/stats?range=day|week|month` - Retorna: - Temperatura média, mínima, máxima - Eficiência média, mínima, máxima ---  📈 `/api/metrics/comparative` - Compara a métrica mais recente com: - Ontem - Semana passada - Mês passado - Usa uma janela de ±15 minutos para buscar dados próximos no tempo  ✅ Status Atual - ✅ Backend completo e funcional - ✅ Banco de dados em SQL puro (exigência do desafio) - ✅ API externa integrada com tratamento de erros - ✅ Interface no Figma finalizada - 🕒 Início da implementação do **frontend** (comportamento, consumo e timer) ---  Conteúdo em cada arquivo:  **server/src/controllers/metricsControllers.ts** ``` import { Request, Response } from 'express'; import { collectAndSaveMetric, getComparativeMetrics, getPreviousMetric, metricService } from '../services/metricService'; import { pool } from '../db/pgClient'; export async function collectMetric(req: Request, res: Response) { try { const metric = await collectAndSaveMetric(); const previous = await getPreviousMetric(metric.id); const trend = calculateTrend(metric.temperature, previous?.temperature); res.status(201).json({ ...metric, clima: metric.clima, trend }); } catch (error) { console.error('Erro ao coletar métrica:', error); res.status(500).json({ error: 'Erro ao coletar métrica.' }); } } function calculateTrend(current: number, previous?: number): 'up' | 'down' | 'stable' { if (previous === undefined) return 'stable'; if (current > previous) return 'up'; if (current < previous) return 'down'; return 'stable'; } export async function getLatestMetric(req: Request, res: Response) { try { const result = await metricService.getLatest(); if (!result) { return res.status(404).json({ error: 'Nenhuma métrica encontrada.' }); } res.json(result); } catch (error) { console.error('Erro ao buscar última métrica:', error); res.status(500).json({ error: 'Erro ao buscar última métrica.' }); } } export async function getHistory(req: Request, res: Response) { const range = req.query.range; if (!isValidRange(range)) { return res.status(400).json({ error: 'Parâmetro range inválido' }); } try { const data = await metricService.getHistoryByRange(range); res.json(data); } catch (error) { console.error('Erro ao buscar histórico:', error); res.status(500).json({ error: 'Erro interno no servidor' }); } } export async function getStats(req: Request, res: Response) { const range = req.query.range; if (!isValidRange(range)) { return res.status(400).json({ error: 'Parâmetro range inválido' }); } try { const stats = await metricService.getStatsByRange(range); res.json(stats); } catch (error) { console.error('Erro ao buscar estatísticas:', error); res.status(500).json({ error: 'Erro interno no servidor' }); } } export async function getComparative(req: Request, res: Response) { try { const latest = await metricService.getLatest(); if (!latest) { return res.status(404).json({ error: 'Nenhuma métrica encontrada.' }); } const referenceDate = new Date(latest.createdAt); const comparative = await getComparativeMetrics(referenceDate); res.json({ reference: latest, comparative, }); } catch (error) { console.error('Erro no comparativo:', error); res.status(500).json({ error: 'Erro interno no servidor.' }); } } function isValidRange(range: any): range is 'day' | 'week' | 'month' { return ['day', 'week', 'month'].includes(range); } ```  **server/src/db/pgClient.ts** ``` import { Pool } from 'pg'; import dotenv from 'dotenv'; dotenv.config(); export const pool = new Pool({ connectionString: process.env.DATABASE_URL, }); ```  **server/src/db/setup.ts** ``` import { pool } from './pgClient'; export async function setupDatabase() { await pool.query(` CREATE TABLE IF NOT EXISTS metric ( "id" SERIAL PRIMARY KEY, "temperature" FLOAT NOT NULL, "efficiency" FLOAT NOT NULL, "location" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMPTZ DEFAULT NOW() ); `); } ```  **server/src/routes/metricRoutes.ts** ``` import express from 'express'; import { collectMetric, getLatestMetric, getHistory, getStats, getComparative } from '../controllers/metricsController'; const router = express.Router(); // Registrar nova métrica (quando usuário acessar) router.get('/collect', collectMetric); router.get('/latest', (req, res, next) => { getLatestMetric(req, res).catch(next); }); router.get('/history', (req, res, next) => { getHistory(req, res).catch(next); }); router.get('/stats', (req, res, next) => { getStats(req, res).catch(next); }); router.get('/comparative', (req, res, next) => { getComparative(req, res).catch(next); }); export default router; ```  **server/src/services/efficiencyService.ts** ``` export function calculateEfficiency(temperature: number): number { if (temperature >= 28) return 100; if (temperature <= 24) return 75; const efficiency = 75 + ((temperature - 24) / (28 - 24)) * 25; return parseFloat(efficiency.toFixed(2)); } ```  **server/src/services/metricService.ts** ``` import { getWeatherFromAPI } from "./weatherService"; import { calculateEfficiency } from "./efficiencyService"; import { pool } from "../db/pgClient"; import { subDays, subWeeks, subMonths, setHours, setMinutes, addMinutes, subMinutes, startOfDay, } from 'date-fns'; // Função para registrar uma nova métrica export async function collectAndSaveMetric() { const city = process.env.LOCATION_DEFAULT || "Patos de Minas"; const { temperature, description } = await getWeatherFromAPI(city); const efficiency = calculateEfficiency(temperature); const insertQuery = ` INSERT INTO metric (temperature, efficiency, location) VALUES ($1, $2, $3) RETURNING *; `; const values = [temperature, efficiency, city]; const result = await pool.query(insertQuery, values); const metric = result.rows[0]; return { ...metric, clima: description }; } // Função auxiliar para calcular data inicial por escopo function getStartDate(range: "day" | "week" | "month") { const now = new Date(); switch (range) { case "day": return startOfDay(now); case "week": return startOfDay(subDays(now, 7)); case "month": return startOfDay(subDays(now, 30)); default: throw new Error("Invalid range"); } } // Serviço principal export const metricService = { // Histórico por escopo getHistoryByRange: async (range: "day" | "week" | "month") => { const from = getStartDate(range); const query = ` SELECT * FROM metric WHERE "createdAt" >= $1 ORDER BY "createdAt" ASC; `; const result = await pool.query(query, [from]); return result.rows; }, // Estatísticas agregadas por escopo getStatsByRange: async (range: "day" | "week" | "month") => { const from = getStartDate(range); const query = ` SELECT AVG(temperature) AS avg_temperature, MIN(temperature) AS min_temperature, MAX(temperature) AS max_temperature, AVG(efficiency) AS avg_efficiency, MIN(efficiency) AS min_efficiency, MAX(efficiency) AS max_efficiency FROM metric WHERE "createdAt" >= $1; `; const result = await pool.query(query, [from]); const row = result.rows[0]; return { temperature: { avg: parseFloat(row.avg_temperature), min: parseFloat(row.min_temperature), max: parseFloat(row.max_temperature), }, efficiency: { avg: parseFloat(row.avg_efficiency), min: parseFloat(row.min_efficiency), max: parseFloat(row.max_efficiency), }, }; }, getLatest: async () => { const query = ` SELECT * FROM metric ORDER BY "id" DESC LIMIT 1; `; const result = await pool.query(query); return result.rows[0]; } }; export async function getComparativeMetrics(referenceDate: Date) { const hour = referenceDate.getHours(); const minute = referenceDate.getMinutes(); const dates = { yesterday: subDays(referenceDate, 1), lastWeek: subWeeks(referenceDate, 1), lastMonth: subMonths(referenceDate, 1), }; const results: Record<string, any> = {}; for (const [key, date] of Object.entries(dates)) { // Base: mesma hora:minuto do referenceDate, mas no período anterior const base = setMinutes(setHours(date, hour), minute); // Arredonda: pega uma janela de ±15 minutos em torno da base const start = subMinutes(base, 15); const end = addMinutes(base, 15); const query = ` SELECT * FROM metric WHERE "createdAt" BETWEEN $1 AND $2 ORDER BY ABS(EXTRACT(EPOCH FROM "createdAt" - $3)) ASC LIMIT 1; `; // $3: tempo de referência exato, para ordenar por proximidade const result = await pool.query(query, [start, end, base]); results[key] = result.rows[0] || null; } return results; } export async function getPreviousMetric(currentId: number) { const result = await pool.query(` SELECT * FROM metric WHERE id <> $1 ORDER BY "createdAt" DESC LIMIT 1; `, [currentId]); return result.rows[0]; } ```  **server/src/services/weatherService.ts** ``` import axios from "axios"; export interface WeatherData { temperature: number; description: string; } export async function getWeatherFromAPI(city: string): Promise<WeatherData> { const apiKey = process.env.WEATHER_API_KEY; if (!apiKey) { throw new Error("API KEY do OpenWeather não configurada."); } try { const response = await axios.get(`https://api.openweathermap.org/data/2.5/weather`, { params: { q: city, appid: apiKey, units: 'metric', lang: 'pt_br' }, timeout: 5000 // ⏰ Define um tempo limite para evitar travamento }); const temperature = response.data.main?.temp; const description = response.data.weather?.[0]?.description; if (temperature === undefined || !description) { throw new Error('Resposta da API do clima está incompleta.'); } return { temperature, description }; } catch (error: any) { if (axios.isAxiosError(error)) { const status = error.response?.status; if (status === 404) { throw new Error(`Cidade "${city}" não encontrada na API de clima.`); } if (status === 401) { throw new Error('API Key inválida ou não autorizada.'); } throw new Error(`Erro ao consultar API de clima: ${error.message}`); } else { throw new Error(`Erro inesperado: ${error.message}`); } } } ```  **server/src/app.ts** ``` import express from 'express'; import path from 'path'; import metricsRoutes from './routes/metricsRoutes'; const app = express(); app.use(express.json()); // Servir arquivos estáticos app.use(express.static(path.join(__dirname, '..', 'public'))); // Rotas da API app.use('/api/metrics', metricsRoutes); export default app; ```  **server/src/index.ts** ``` import dotenv from 'dotenv'; import app from './app'; import { setupDatabase } from './db/setup'; dotenv.config(); const PORT = process.env.PORT || 3000; setupDatabase().then(() => { app.listen(PORT, () => { console.log(`Servidor rodando em http://localhost:${PORT}`); }); }).catch(err => { console.error('Erro ao configurar banco de dados:', err); }); ``` ---  FrontEnd  public/index.html ``` <!DOCTYPE html> <html lang="pt-br"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Effy Analytics</title> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=Inter:opsz,wght@14..32,100..900&display=swap" rel="stylesheet"> <link rel="stylesheet" href="./css/styles.css"> </head> <body> <header> <h1 class="main-title">Effy <span>Analytics</span></h1> <div class="header-content"> <div class="container-localization"> <span data-lucide="map-pin" class="icon"></span> <h2 class="value-localization">Patos de minas</h2> </div> <div class="container-timer"> <span data-lucide="alarm-clock" class="icon"></span> <p><span class="value-timer">30</span>s</p> </div> </div> </header> <main> <nav> <ul> <li> <a aria-label="Dashboard Home" class="nav-button active" href=""> <span data-lucide="house" class="icon"></span> </a> </li> </ul> </nav> <section class="container-dashboard"> <div class="container"> <h2>Dados Atuais</h2> <div class="container-card-data"> <div class="card-data"> <div class="header-card-data"> <p>Horário</p> <span data-lucide="alarm-clock" class="icon"></span> </div> <span class="card-data-info value-time">19:06:21</span> </div> <div class="card-data"> <div class="header-card-data"> <p>Data</p> <span data-lucide="calendar" class="icon"></span> </div> <span class="card-data-info value-date">29/07/2006</span> </div> <div class="card-data"> <div class="header-card-data"> <p>Temperatura</p> <span data-lucide="thermometer" class="icon"></span> </div> <p class="card-data-info"><span class="value-temperature">29,5</span>°C</p> <span data-lucide="arrow-right" class="icon value-temperature-trend"></span> <!-- Rotacionar com classes up (apontando na diagonal para cima), down (diagonal para baixo), stable (padrão)--> </div> <div class="card-data"> <div class="header-card-data"> <p>Eficiência</p> <span data-lucide="gauge" class="icon"></span> </div> <p class="card-data-info"><span class="value-efficiency">85,2</span>%</p> <span data-lucide="arrow-right" class="icon value-efficiency-trend"></span> <!-- Rotacionar com classes up (apontando na diagonal para cima), down (diagonal para baixo), stable (padrão)--> </div> </div> </div> <div class="container"> <h2>Resumo</h2> <div class="container-card-media"> <div class="card-media"> <div class="header-card-media"> <span>Média de</span> <div> <span data-lucide="wind" class="icon"></span> <p class="value-clima">Céu Limpo</p> </div> </div> <div class="content-card-media"> <span data-lucide="thermometer" class="icon"></span> <p><span class="value-media-temperature">29,05</span>°C</p> </div> <div class="range-card-media"> <p>min: <span class="value-min-temperature">22</span>°C</p> <p>min: <span class="value-max-temperature">32</span>°C</p> </div> </div> <div class="card-media"> <div class="header-card-media"> <span>Média de</span> <div> <span data-lucide="square-kanban" class="icon"></span> <p>Média:<span class="value-defcit">-24</span>%</p> </div> </div> <div class="content-card-media"> <span data-lucide="gauge" class="icon"></span> <p><span class="value-media-efficiency">85,05</span>%</p> </div> <div class="range-card-media"> <p>min: <span class="value-min-efficiency">52</span>%</p> <p>min: <span class="value-max-efficiency">100</span>%</p> </div> </div> </div> </div> <div class="container"> <h2>Comparativo</h2> <div class="container-card-comparative"> <div class="card-comparative"> <h3>Ontem</h3> <div class="card-comparative-content"> <div class="temperature-comparative"> <span data-lucide="thermometer" class="icon"></span> <p><span class="value-yesterday-temperature">29,05</span>°C</p> </div> <div class="efficiency-comparative"> <span data-lucide="gauge" class="icon"></span> <p><span class="value-yesterday-efficiency">85,05</span>%</p> </div> </div> </div> <div class="card-comparative"> <h3>Last Week</h3> <div class="card-comparative-content"> <div class="temperature-comparative"> <span data-lucide="thermometer" class="icon"></span> <p><span class="value-last-week-temperature">29,05</span>°C</p> </div> <div class="efficiency-comparative"> <span data-lucide="gauge" class="icon"></span> <p><span class="value-last-week-efficiency">85,05</span>%</p> </div> </div> </div> <div class="card-comparative"> <h3>Last Month</h3> <div class="card-comparative-content"> <div class="temperature-comparative"> <span data-lucide="thermometer" class="icon"></span> <p><span class="value-last-month-temperature">29,05</span>°C</p> </div> <div class="efficiency-comparative"> <span data-lucide="gauge" class="icon"></span> <p><span class="value-last-month-efficiency">85,05</span>%</p> </div> </div> </div> </div> </div> <div class="container-card-graph"> </div> </section> </main> <script src="./js/scripts.js"></script> <script src="https://unpkg.com/lucide@latest"></script> <script> document.addEventListener('DOMContentLoaded', () => { lucide.createIcons(); }); </script> <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script> </body> </html> ```  public/js/scripts.js ``` document.addEventListener("DOMContentLoaded", function () { let chart; const labels = []; const temperatureData = []; const efficiencyData = []; const options = { chart: { type: 'line', height: '400px', animations: { enabled: true, easing: 'easeinout', speed: 500, animateGradually: { enabled: true, delay: 150 }, dynamicAnimation: { enabled: true, speed: 500 } } }, stroke: { width: 4, curve: 'smooth' }, series: [ { name: 'Temperatura (°C)', data: [] }, { name: 'Eficiência (%)', data: [] } ], xaxis: { categories: [], title: { text: 'Horário' } }, yaxis: { title: { text: 'Temperatura (°C) / Eficiência (%)' } }, colors: ['FDAD15', '2AC670'], fill: { type: 'gradient', gradient: { shade: 'light', type: "vertical", shadeIntensity: 0.4, opacityFrom: .8, opacityTo: .5, stops: [0, 100] } }, markers: { size: 5, colors: ['FDAD15', '2AC670'], strokeColors: 'fff', strokeWidth: 2 }, legend: { position: 'top', horizontalAlign: 'left' }, tooltip: { theme: 'light' }, grid: { borderColor: "e0e0e0", row: { colors: ['f9f9f9', 'transparent'], opacity: 0.5 } } }; chart = new ApexCharts(document.querySelector(".container-card-graph"), options); chart.render(); // Simulação de chamada à API a cada 30s setInterval(fetchNewData, 1000); // ou 1000 para testar mais rápido function fetchNewData() { // Aqui você faria um fetch real const now = new Date(); const timeLabel = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); const newTemp = (Math.random() * 10 + 25).toFixed(2); const newEff = (Math.random() * 20 + 80).toFixed(2); // Atualiza arrays labels.push(timeLabel); temperatureData.push(parseFloat(newTemp)); efficiencyData.push(parseFloat(newEff)); // Limita os dados a, por exemplo, últimos 10 pontos if (labels.length > 10) { labels.shift(); temperatureData.shift(); efficiencyData.shift(); } // Atualiza gráfico chart.updateOptions({ xaxis: { categories: labels } }); chart.updateSeries([ { name: 'Temperatura (°C)', data: temperatureData }, { name: 'Eficiência (%)', data: efficiencyData } ]); } // Para inicialização imediata fetchNewData(); }); ```  public/css/styles.css ``` @import url(./header.css); @import url(./nav.css); @import url(./dashboard.css); /* Corrigido 'deshboard.css' para 'dashboard.css' */ :root { --primary-text-color: 1E1E1E; --secondary-text-color: 5E5E5E; --primary-bg-color: F9FAFB; --secondary-bg-color: FFFFFF; --primary-color: FFE066; --positive-color: 2AC670; --negative-color: FF6252; --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); --radius: 12px; --font: 'Inter', sans-serif; } * { margin: 0; padding: 0; box-sizing: border-box; font-family: var(--font), sans-serif; } body { background-color: var(--primary-bg-color); overflow-x: hidden; } ```  public/css/deshboard.css ``` main { margin: 0 2vw; width: 100vw; display: flex; gap: 2vw; position: relative; } /* Dashboard com 2 linhas: 3 colunas acima, 1 abaixo */ .container-dashboard { margin-left: 10vw; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: 1fr 1fr; width: 85vw; gap: 1.5rem; } .container h2 { font-size: 1.2rem; color: var(--text-color); margin-bottom: 0.5em; font-weight: 500; } .container-card-data { height: 100%; display: grid; grid-template-columns: repeat(2, 1fr); /* 2 colunas */ grid-template-rows: repeat(2, 1fr);    /* 2 linhas */ gap: 1rem; background-color: f4f4f4; border-radius: 10px; } .card-data { background-color: white; padding: 0.8rem; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 0.5rem; } .container-card-media { height: 100%; display: grid; grid-template-rows: repeat(2, 1fr); gap: 0.5rem; } .card-media { background-color: white; padding: 0.8rem; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 0.5rem; } .header-card-media { display: flex; justify-content: space-between; margin: 0 1em; } .header-card-media div { display: flex; align-items: center; gap: 0.5em; } .content-card-media { display: flex; color: var(--text-color); gap: 0.5em; align-items: center; margin: 0.5em 0; margin-left: 2em; } .content-card-media p { font-size: 1.5rem; font-weight: 700; color: var(--text-color); } .range-card-media { display: flex; align-items: center; gap: 2em; margin-left: 1.2em; font-size: 0.8rem; } .container { height: 50vh; } .container-card-comparative { height: 100%; display: grid; grid-template-rows: repeat(3, 1fr); gap: 0.5rem; } .card-comparative { background-color: white; padding: 0.8rem 1.2em; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 0.5rem; } .card-comparative h3{ font-size: 1rem; color: var(--text-color); margin-left: .5em; } .card-comparative-content { display: flex; color: var(--text-color); justify-content: space-between; align-items: center; margin: .2em 12%; } .card-comparative-content div { display: flex; align-items: center; gap: 0.5em; } .container-card-graph { background-color: var(--secondary-bg-color); margin-top: 1em; height: 50vh; width: 100%; grid-column: 1 / -1; height: 400px !important; /* Altura fixa */ position: relative; } ```  public/css/nav.css ``` nav { background-color: var(--secondary-bg-color); display: flex; flex-direction: column; width: 7vw; height: 80%; border-radius: 10px; padding: 5vh 0; position: fixed; align-items: center; } nav ul { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 10px; } nav ul li{ width: 4vw; height: 4vw; border-radius: 100%; display: flex; align-items: center; justify-content: center; } .nav-button { display: flex; width: 100%; border-radius: 100%; height: 100%; align-items: center; justify-content: center; color: var(--text-color); } .active { background-color: var(--primary-color); } ```  public/css/header.css ``` header { display: flex; justify-content: space-between; padding: 0 2vw; height: 15vh; align-items: center; } .main-title { font-size: 1.8rem; font-weight: 700; color: var(--primary-text-color); } .main-title span { font-weight: 300; color: var(--secondary-text-color); } .header-content { display: flex; gap: 5vw; align-items: center; justify-content: center; font-weight: 300; color: var(--secondary-text-color); margin-right: 8vw; } .header-content div { display: flex; align-items: center; gap: 0.5em; justify-content: center; } .value-localization { font-size: 1rem; font-weight: 300; } .container-timer p { font-size: 0.8rem; font-weight: 300; } .value-timer { font-size: 1rem; } ```